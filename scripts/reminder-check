#!/usr/bin/env node

/**
 * Reminder Review CLI
 * Scans various sources for reminders and surfaces upcoming/overdue items
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m'
};

// Emojis for different reminder types
const emojis = {
  overdue: 'üö®',
  today: '‚è∞',
  thisWeek: 'üìÖ',
  future: 'üîÆ',
  cron: '‚öôÔ∏è',
  memory: 'üß†',
  todo: '‚úÖ'
};

class ReminderChecker {
  constructor(options = {}) {
    this.daysAhead = options.days || 7;
    this.showAll = options.all || false;
    this.now = new Date();
    this.reminders = [];
  }

  // Parse date strings in various formats
  parseDate(text) {
    const patterns = [
      // ISO format
      /(\d{4}-\d{2}-\d{2})/,
      // MM/DD format
      /(\d{1,2}\/\d{1,2}(?:\/\d{2,4})?)/,
      // Natural language
      /\b(today|tomorrow|next week|this week)\b/i,
      // Specific days
      /\b(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/i
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        return this.convertToDate(match[1]);
      }
    }
    return null;
  }

  convertToDate(dateStr) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    switch (dateStr.toLowerCase()) {
      case 'today':
        return today;
      case 'tomorrow':
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);
        return tomorrow;
      case 'this week':
        const endOfWeek = new Date(today);
        endOfWeek.setDate(today.getDate() + (7 - today.getDay()));
        return endOfWeek;
      case 'next week':
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        return nextWeek;
      default:
        // Try parsing as regular date
        const parsed = new Date(dateStr);
        return isNaN(parsed) ? null : parsed;
    }
  }

  // Scan cron jobs for reminders
  async scanCronJobs() {
    try {
      const cronResult = execSync('clawdbot cron action:list 2>/dev/null || echo "[]"', { encoding: 'utf-8' });
      const cronJobs = JSON.parse(cronResult);

      for (const job of cronJobs) {
        if (this.isReminderJob(job)) {
          const reminder = {
            source: 'cron',
            type: emojis.cron,
            content: job.text || job.name || 'Unnamed reminder',
            dueDate: this.getNextCronRun(job.schedule),
            jobId: job.id,
            raw: job
          };
          this.reminders.push(reminder);
        }
      }
    } catch (error) {
      // Silently continue if cron command fails
    }
  }

  isReminderJob(job) {
    const text = (job.text || job.name || '').toLowerCase();
    const reminderKeywords = ['remind', 'remember', 'follow up', 'check', 'review', 'due'];
    return reminderKeywords.some(keyword => text.includes(keyword));
  }

  getNextCronRun(schedule) {
    // Simplified cron parser for common patterns
    // This is a basic implementation - could be enhanced with a proper cron library
    if (!schedule) return null;
    
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(now.getDate() + 1);
    tomorrow.setHours(9, 0, 0, 0); // Default to 9 AM tomorrow
    
    return tomorrow;
  }

  // Scan memory files for TODOs and reminders
  async scanMemoryFiles() {
    const memoryDir = path.join(process.cwd(), 'memory');
    const mainMemory = path.join(process.cwd(), 'MEMORY.md');

    // Scan main MEMORY.md
    if (fs.existsSync(mainMemory)) {
      this.scanFileForReminders(mainMemory, 'main-memory');
    }

    // Scan daily memory files
    if (fs.existsSync(memoryDir)) {
      const files = fs.readdirSync(memoryDir)
        .filter(file => file.match(/^\d{4}-\d{2}-\d{2}\.md$/))
        .sort()
        .slice(-30); // Last 30 days

      for (const file of files) {
        const filePath = path.join(memoryDir, file);
        this.scanFileForReminders(filePath, 'daily-memory');
      }
    }
  }

  scanFileForReminders(filePath, sourceType) {
    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (this.isReminderLine(line)) {
          const dueDate = this.parseDate(line);
          const reminder = {
            source: sourceType,
            type: this.getReminderType(line),
            content: this.cleanReminderText(line),
            dueDate: dueDate,
            file: path.basename(filePath),
            lineNumber: i + 1
          };
          this.reminders.push(reminder);
        }
      }
    } catch (error) {
      // Silently continue if file reading fails
    }
  }

  isReminderLine(line) {
    // Skip completed items
    if (/\[\s*x\s*\]/i.test(line)) return false;
    
    const reminderPatterns = [
      /^[-*]\s*\[\s*\]\s*/i,  // - [ ] or * [ ] (unchecked tasks only)
      /\b(todo|reminder|remember|follow.?up|due|deadline)\s*:/i,
      /^[-*]\s*(todo|reminder|remember)/i,
      /\b(todo)\b/i  // standalone TODO mentions
    ];
    
    return reminderPatterns.some(pattern => pattern.test(line));
  }

  getReminderType(line) {
    if (line.includes('TODO') || line.includes('todo')) return emojis.todo;
    if (line.includes('remember') || line.includes('reminder')) return emojis.memory;
    return emojis.memory;
  }

  cleanReminderText(line) {
    // Remove checkbox syntax and common prefixes
    return line
      .replace(/^[-*]\s*\[\s*\]\s*/i, '')
      .replace(/^[-*]\s*/i, '')
      .replace(/^\d+\.\s*/i, '')
      .trim();
  }

  // Categorize reminders by due date
  categorizeReminders() {
    const today = new Date();
    today.setHours(23, 59, 59, 999);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    
    const weekFromNow = new Date(today);
    weekFromNow.setDate(today.getDate() + this.daysAhead);

    const categories = {
      overdue: [],
      today: [],
      thisWeek: [],
      future: [],
      noDate: []
    };

    for (const reminder of this.reminders) {
      if (!reminder.dueDate) {
        categories.noDate.push(reminder);
      } else if (reminder.dueDate < this.now) {
        categories.overdue.push(reminder);
      } else if (reminder.dueDate <= today) {
        categories.today.push(reminder);
      } else if (reminder.dueDate <= weekFromNow) {
        categories.thisWeek.push(reminder);
      } else {
        categories.future.push(reminder);
      }
    }

    return categories;
  }

  // Format date for display
  formatDate(date) {
    if (!date) return '';
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    
    date.setHours(0, 0, 0, 0);
    
    if (date.getTime() === today.getTime()) {
      return 'Today';
    } else if (date.getTime() === tomorrow.getTime()) {
      return 'Tomorrow';
    } else {
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
      });
    }
  }

  // Display results
  displayResults(categories) {
    console.log(`\n${colors.cyan}üîç Reminder Review${colors.reset}`);
    console.log(`${colors.gray}Scanned: cron jobs, memory files${colors.reset}\n`);

    let totalCount = 0;

    // Overdue (highest priority)
    if (categories.overdue.length > 0) {
      console.log(`${colors.red}${emojis.overdue} Overdue (${categories.overdue.length})${colors.reset}`);
      for (const reminder of categories.overdue) {
        this.displayReminder(reminder, colors.red);
      }
      console.log();
      totalCount += categories.overdue.length;
    }

    // Today
    if (categories.today.length > 0) {
      console.log(`${colors.yellow}${emojis.today} Due Today (${categories.today.length})${colors.reset}`);
      for (const reminder of categories.today) {
        this.displayReminder(reminder, colors.yellow);
      }
      console.log();
      totalCount += categories.today.length;
    }

    // This week
    if (categories.thisWeek.length > 0) {
      console.log(`${colors.blue}${emojis.thisWeek} This Week (${categories.thisWeek.length})${colors.reset}`);
      for (const reminder of categories.thisWeek) {
        this.displayReminder(reminder, colors.blue);
      }
      console.log();
      totalCount += categories.thisWeek.length;
    }

    // Future (only if showing all)
    if (this.showAll && categories.future.length > 0) {
      console.log(`${colors.green}${emojis.future} Future (${categories.future.length})${colors.reset}`);
      for (const reminder of categories.future) {
        this.displayReminder(reminder, colors.green);
      }
      console.log();
      totalCount += categories.future.length;
    }

    // No date (only if showing all)
    if (this.showAll && categories.noDate.length > 0) {
      console.log(`${colors.gray}üìù No Due Date (${categories.noDate.length})${colors.reset}`);
      for (const reminder of categories.noDate) {
        this.displayReminder(reminder, colors.gray);
      }
      console.log();
      totalCount += categories.noDate.length;
    }

    // Summary
    if (totalCount === 0) {
      console.log(`${colors.green}‚úÖ No reminders need attention!${colors.reset}\n`);
    } else {
      console.log(`${colors.cyan}üìä Found ${totalCount} reminders${colors.reset}`);
      if (categories.overdue.length > 0) {
        console.log(`${colors.red}   ${categories.overdue.length} overdue${colors.reset}`);
      }
      if (categories.today.length > 0) {
        console.log(`${colors.yellow}   ${categories.today.length} due today${colors.reset}`);
      }
      if (categories.thisWeek.length > 0) {
        console.log(`${colors.blue}   ${categories.thisWeek.length} due this week${colors.reset}`);
      }
      console.log();
    }
  }

  displayReminder(reminder, color) {
    const dueDateStr = reminder.dueDate ? `${colors.gray}(${this.formatDate(reminder.dueDate)})${colors.reset}` : '';
    const sourceStr = `${colors.gray}[${reminder.source}]${colors.reset}`;
    
    console.log(`  ${reminder.type} ${color}${reminder.content}${colors.reset} ${dueDateStr} ${sourceStr}`);
    
    if (reminder.file) {
      console.log(`    ${colors.gray}‚Üí ${reminder.file}:${reminder.lineNumber || '?'}${colors.reset}`);
    }
  }

  // Main execution
  async run() {
    try {
      await this.scanCronJobs();
      await this.scanMemoryFiles();
      
      const categories = this.categorizeReminders();
      this.displayResults(categories);
    } catch (error) {
      console.error(`${colors.red}Error: ${error.message}${colors.reset}`);
      process.exit(1);
    }
  }
}

// CLI argument parsing
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    days: 7,
    all: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--help' || arg === '-h') {
      showHelp();
      process.exit(0);
    } else if (arg === '--days' || arg === '-d') {
      const daysValue = parseInt(args[i + 1]);
      if (daysValue && daysValue > 0) {
        options.days = daysValue;
        i++; // Skip next arg
      } else {
        console.error('Error: --days requires a positive number');
        process.exit(1);
      }
    } else if (arg === '--all' || arg === '-a') {
      options.all = true;
    } else {
      console.error(`Error: Unknown option '${arg}'`);
      showHelp();
      process.exit(1);
    }
  }

  return options;
}

function showHelp() {
  console.log(`
üîç Reminder Review CLI

USAGE:
  reminder-check [OPTIONS]

OPTIONS:
  -d, --days N    Look N days ahead for reminders (default: 7)
  -a, --all       Show all reminders regardless of date
  -h, --help      Show this help message

DESCRIPTION:
  Scans various sources for reminders and surfaces upcoming/overdue items:
  
  ‚Ä¢ Cron jobs (reminder-type jobs)
  ‚Ä¢ Daily memory files (TODOs, reminders)
  ‚Ä¢ MEMORY.md (long-term pending items)

EXAMPLES:
  reminder-check              # Check next 7 days
  reminder-check --days 14    # Check next 2 weeks
  reminder-check --all        # Show all reminders
  reminder-check --help       # Show this help

OUTPUT:
  Reminders are categorized by urgency:
  üö® Overdue   - Past due date
  ‚è∞ Today     - Due today
  üìÖ This Week - Due within specified days
  üîÆ Future    - Beyond specified timeframe (with --all)
`);
}

// Main execution
if (require.main === module) {
  const options = parseArgs();
  const checker = new ReminderChecker(options);
  checker.run();
}

module.exports = ReminderChecker;