#!/usr/bin/env node

/**
 * Session Summary Generator
 * 
 * Generates digestible summaries of Clawdbot conversations from daily memory files.
 * Useful for Sam to quickly understand what happened each day.
 */

const fs = require('fs');
const path = require('path');

// CLI argument parsing
const args = process.argv.slice(2);
const showHelp = args.includes('--help') || args.includes('-h');
const verbose = args.includes('--verbose') || args.includes('-v');

// Help text
const HELP = `
Session Summary Generator

USAGE:
  session-summary [DATE] [OPTIONS]

ARGUMENTS:
  DATE          Date in YYYY-MM-DD format (defaults to today)

OPTIONS:
  --help, -h    Show this help message
  --verbose, -v Show detailed analysis

EXAMPLES:
  session-summary                    # Today's summary
  session-summary 2026-01-30        # Specific date summary
  session-summary --verbose         # Detailed summary for today

INPUT:
  Reads from memory/YYYY-MM-DD.md files in current directory or ~/clawd/
`;

if (showHelp) {
  console.log(HELP);
  process.exit(0);
}

// Date handling
const dateArg = args.find(arg => /^\d{4}-\d{2}-\d{2}$/.test(arg));
const targetDate = dateArg || new Date().toISOString().split('T')[0];

// File paths to check
const possiblePaths = [
  path.join(process.cwd(), 'memory', `${targetDate}.md`),
  path.join(process.env.HOME || '~', 'clawd', 'memory', `${targetDate}.md`)
];

// Find the memory file
let memoryFile = null;
for (const filePath of possiblePaths) {
  if (fs.existsSync(filePath)) {
    memoryFile = filePath;
    break;
  }
}

if (!memoryFile) {
  console.error(`âŒ No memory file found for ${targetDate}`);
  console.error(`   Checked: ${possiblePaths.join(', ')}`);
  process.exit(1);
}

// Read and parse the memory file
function parseMemoryFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const lines = content.split('\n').map(line => line.trim()).filter(Boolean);
  
  const entries = [];
  let currentEntry = null;
  
  for (const line of lines) {
    // Look for timestamp pattern (HH:MM - text)
    const timestampMatch = line.match(/^(\d{1,2}:\d{2})\s*[-â€“]\s*(.+)/);
    
    if (timestampMatch) {
      // Save previous entry
      if (currentEntry) {
        entries.push(currentEntry);
      }
      
      // Start new entry
      currentEntry = {
        time: timestampMatch[1],
        text: timestampMatch[2],
        details: []
      };
    } else if (currentEntry && line.length > 0) {
      // Add detail to current entry
      currentEntry.details.push(line);
    } else if (!currentEntry && line.length > 0) {
      // Text without timestamp - create a general entry
      entries.push({
        time: null,
        text: line,
        details: []
      });
    }
  }
  
  // Don't forget the last entry
  if (currentEntry) {
    entries.push(currentEntry);
  }
  
  return entries;
}

// Categorize entries by content
function categorizeEntries(entries) {
  const categories = {
    decisions: [],
    tasks: [],
    conversations: [],
    technical: [],
    meetings: [],
    other: []
  };
  
  const patterns = {
    decisions: /\b(decided|decision|chose|concluded|agreed|resolved)\b/i,
    tasks: /\b(todo|task|need to|should|will|action|complete|finish)\b/i,
    technical: /\b(code|build|debug|fix|deploy|git|api|database|error)\b/i,
    meetings: /\b(meeting|call|zoom|discussion|sync|standup)\b/i
  };
  
  for (const entry of entries) {
    const fullText = [entry.text, ...entry.details].join(' ');
    let categorized = false;
    
    for (const [category, pattern] of Object.entries(patterns)) {
      if (pattern.test(fullText)) {
        categories[category].push(entry);
        categorized = true;
        break;
      }
    }
    
    if (!categorized) {
      categories.conversations.push(entry);
    }
  }
  
  return categories;
}

// Generate summary
function generateSummary(entries, categories) {
  const totalEntries = entries.length;
  const timeSpan = getTimeSpan(entries);
  
  let summary = `# Daily Summary - ${targetDate}\n\n`;
  
  // Overview
  summary += `ğŸ“… **${totalEntries} entries** recorded`;
  if (timeSpan) {
    summary += ` spanning ${timeSpan}`;
  }
  summary += '\n\n';
  
  // Key sections
  const sections = [
    { name: 'ğŸ¯ Decisions & Resolutions', items: categories.decisions },
    { name: 'ğŸ“‹ Tasks & Actions', items: categories.tasks },
    { name: 'ğŸ› ï¸ Technical Work', items: categories.technical },
    { name: 'ğŸ‘¥ Meetings & Calls', items: categories.meetings },
    { name: 'ğŸ’¬ Conversations', items: categories.conversations }
  ];
  
  for (const section of sections) {
    if (section.items.length > 0) {
      summary += `## ${section.name}\n\n`;
      
      for (const item of section.items.slice(0, verbose ? 10 : 5)) {
        summary += `- `;
        if (item.time) {
          summary += `**${item.time}** `;
        }
        summary += `${item.text}`;
        
        if (verbose && item.details.length > 0) {
          summary += `\n  - ${item.details.join('\n  - ')}`;
        }
        summary += '\n';
      }
      
      if (!verbose && section.items.length > 5) {
        summary += `  *(+${section.items.length - 5} more entries)*\n`;
      }
      summary += '\n';
    }
  }
  
  // Other entries
  if (categories.other.length > 0) {
    summary += `## ğŸ“ Other Notes\n\n`;
    for (const item of categories.other.slice(0, 3)) {
      summary += `- ${item.text}\n`;
    }
    if (categories.other.length > 3) {
      summary += `  *(+${categories.other.length - 3} more)*\n`;
    }
    summary += '\n';
  }
  
  // Summary stats
  if (verbose) {
    summary += `---\n\n`;
    summary += `**Summary Stats:**\n`;
    summary += `- Total entries: ${totalEntries}\n`;
    summary += `- Decisions: ${categories.decisions.length}\n`;
    summary += `- Tasks: ${categories.tasks.length}\n`;
    summary += `- Technical: ${categories.technical.length}\n`;
    summary += `- Meetings: ${categories.meetings.length}\n`;
    summary += `- Conversations: ${categories.conversations.length}\n`;
    summary += `- Other: ${categories.other.length}\n`;
  }
  
  return summary;
}

// Calculate time span
function getTimeSpan(entries) {
  const times = entries
    .filter(entry => entry.time)
    .map(entry => entry.time)
    .sort();
  
  if (times.length >= 2) {
    return `${times[0]} - ${times[times.length - 1]}`;
  } else if (times.length === 1) {
    return `around ${times[0]}`;
  }
  
  return null;
}

// Main execution
try {
  console.error(`ğŸ“– Reading ${memoryFile}...`);
  
  const entries = parseMemoryFile(memoryFile);
  
  if (entries.length === 0) {
    console.log(`# Daily Summary - ${targetDate}\n\nğŸ¤· No entries found for this date.`);
    process.exit(0);
  }
  
  const categories = categorizeEntries(entries);
  const summary = generateSummary(entries, categories);
  
  console.log(summary);
  
} catch (error) {
  console.error(`âŒ Error generating summary: ${error.message}`);
  process.exit(1);
}